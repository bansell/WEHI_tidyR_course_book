[
["index.html", "Introduction to R - tidyverse Preface Before we begin", " Introduction to R - tidyverse Brendan R. E. Ansell @ansellbr3 Preface This document contains the material covered in the Introduction to R (tidyverse) course taught at the Walter and Eliza Hall Institute of Medical Research. The course is taught to biomedical scientists, but the material and the teaching examples are very broad. Skills taught in this workshop can be applied to many disciplines in academia and industry. Chapters 1 through 5 make use of popular (non-biological) teaching data sets available through R. Chapters 6 onwards introduce some types biological data. Our aim with this material is to improve the transparency, reproducibility and efficiency of scientific research by enabling scientists to conduct data analysis and visualization in R. This material is designed to be taught in a workshop setting over consecutive weeks, however we have now made it available online for those who cannot attend the workshop, or want to refresh or develop their skills. The majority of this material is inspired by / modified from from the excellent book R for Data Science by Hadley Wickham &amp; Garrett Grolemund. I thank WEHI for suppoprting this initiative, and the Melbourne University Research Platforms Unit, Prof Melanie Bahlo, A/Prof Marnie Blewitt, A/Prof Anne Voss, Dr Luke Gandolfo, Dr Saskia Freytag, Stuart Lee and Jacob Munro who helped with discussion and development of this material. Before we begin In order to use R interactively and easily, participants will need to install R and then download the RStudio software. More detailed instructions are available here. "],
["week-1-part-1-the-basics.html", "Week 1. Part 1: The basics", " Week 1. Part 1: The basics "],
["welcome-to-r.html", "1 Welcome to R! 1.1 A look around RStudio 1.2 Console Pane 1.3 Environment/History Pane 1.4 Plotting Pane 1.5 Open a new R script 1.6 Comments 1.7 Executing commands 1.8 Simple maths in R 1.9 Help!! 1.10 Variables", " 1 Welcome to R! R is a computer programing language that is increasingly used for ‘data science’, that is, the manipulation, summarization, and visualization of large datasets. Data comes in many shapes and sizes, however this course is designed to teach you the skills to work with tabular data (rows and columns) such as is often handled in Microsoft Excel. An example of ‘tabular data’ is shown below. This data concerns different models of car, which we will return to later. Ignore the code block (in grey) for now. mpg %&gt;% head() ## # A tibble: 6 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compact ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compact ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compact ## 4 audi a4 2 2008 4 auto(av) f 21 30 p compact ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compact ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compact 1.1 A look around RStudio To get the best out of R, we recommend using the RStudio software which you should now have installed on your computer. Open RStudio. You will see 3 windows (aka ‘panes’). Each window has a different function. img from: https://d33wubrfki0l68.cloudfront.net/9a23d664f0f49bc2ef8e78bed6277dd48bd2b96d/af132/diagrams/rstudio-console.png 1.2 Console Pane On the left hand side you have the ‘console’. You can enter commands (code that R can ‘understand’) in this window, and you will get a response to your commands (‘output’) here too. The console is useful for trying out code, but will not save any of your code, so we don’t recommend that you use it exclusively. 1.3 Environment/History Pane At the top right is the environment pane. Data that you create, or that you import from other places, will be listed here. This data is available for you to access at any time while your RStudio session is open. It is therefore said to be ‘in the working environment.’ The History pane contains a list of commands you have previously entered. 1.4 Plotting Pane At the bottom right is the plotting (‘Plots’) pane. Here you can immediately see the results of the R code you use to make graphs/charts. There are other tabs here as well which we will introduce later. 1.5 Open a new R script Because we want to save our code to return to and build on, or use to refresh our memory later, we want to save it in a text file. Go to File &gt; New File &gt; R Script. A new pane will appear at the top left. Save this empty text file as ‘Week_1_tidyverse.R’ in a convenient location. From now on we will type commands in to the text file, and see the results of our commands either in the console pane, or the plotting pane. 1.6 Comments When working in R it is very handy to make notes to yourself about what the code is doing. In R, any text that appears after the hash symbol ‘#’ is called a ‘comment.’ R can’t see this text, and won’t try to run it as commands. Comments are useful for reminding your future self what you were aiming to do with a particular line of code, and what was or wasnt working. We will use comments extensively in this course. Try writing your first comment in your R text file (top left panel) #This is a comment. ignored by R but useful for me! 1.7 Executing commands Executing commands, also called ‘running code’ is the process of submitting a command to your computer, which does some computation and returns an answer. There are a few ways to do this in RStudio. We can: select the line(s) of code using the mouse, and then click ‘Run’ at the top right corner of the R text file. click anyware on the line of code and click ’Run click anyware on the line of code and type Cmd + Return (mac), or Ctrl + Return (pc) We suggest the third option, which is fastest. When you type in, and then run the commands shown in the grey boxes below, you should see the result in the Console pane at bottom left. 1.8 Simple maths in R We can use R as a caculator to do simple maths 1 + 100 ## [1] 101 More complex calculator functions are ‘built in’ to R, which is the reason it is popular among mathematicians and statisticians. To use these functions, we first type the function, then enter the number of interest between round brackets. For example, to take the log or square root of 100: log(100) ## [1] 4.60517 sqrt(100) ## [1] 10 Notice that the ‘square root’ function is abbreviated to ‘sqrt()’. This is to make writing R code faster, however the draw back is that some functions are hard to remember, or to interpret. 1.9 Help!! To find out more about what a function in R does, add a ‘?’ before the function name, and leave the round brackets empty. Then run the code: #get help on R functions by using &quot;?&quot; ?sqrt() You will see the ‘Help’ pane at bottom right springs to life. These help documents give detailed explanations about the function, including how it is used, what input it requires, and, most importantly at the bottom Examples! You can copy and paste these examples in to your R text file, select and then run them. You should see the output indended by the function authors. NB dont worry for now that the sqrt() example is quite complicated. NBB all R ‘functions’ are little programs that were written by other people. There are 1000s of functions available for R, which makes your life simpler because you dont have to program them all from scratch. 1.10 Variables A ‘variable’ is a bit of tricky concept, but very important for understanding R. Essentially, a variable is a symbol that we use in place of another value. Usually the other value is a larger/longer form of data. We can tell R to store a lot of data, for example, in a variable named ‘x’. When we execute the command ‘x’, R returns all of the data that we stored there. For now however we’ll just use a tiny data set: the number 5. To store some data in a variable, we need to use a special symbol ‘&lt;-’ which in our case tells R to ‘assign the value 5 to the variable x’. This is called the ‘assignment operator’. Let’s see how this works # create a variable called &#39;x&#39;, that will contain the number 5. x &lt;- 5 R won’t return anything in the Console, but note that you now have a new entry in the ‘Environment pane’. The variable name is at the left (‘x’) and the value that is stored in that variable, is displayed on the right (5). We can now use ‘x’ in place of 5: x + 20 ## [1] 25 x * 50 ## [1] 250 Can you work out what the * symbol is used for in R? 1.10.1 A note on variables Variables are sometimes refered to as ‘objects’. In R there are different conventions about how to name variables, but most importantly they: cannot begin with a number should begin with an alphabetical letter Variables are also case sensitive: X ## Error in eval(expr, envir, enclos): object &#39;X&#39; not found As we can see, ‘x’ is not the same as ‘X’. Variables can take any name, but its best to use something that makes sense to you, and will likely make sense to others who may read your code. R_at_WEHI &lt;- 100 For example, this code will work, but is not very intitive to humans: log(R_at_WEHI) ## [1] 4.60517 You may be wondering “why bother with assigning variables, when its less text to type ‘100’?” This is because we can store huge amounts of data in a single variable. For example, we can store a list of 50 numbers in a variable, and do maths on them all at once. First we create a list of 50 numbers, using a quick trick ‘1:50’ which means ‘every whole number from 1 to 50’. Let’s make a variable called ‘long_x’ that stores 1:50. long_x &lt;- 1:50 Now we can multiply every number by 10 long_x * 10 ## [1] 10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250 ## [26] 260 270 280 290 300 310 320 330 340 350 360 370 380 390 400 410 420 430 440 450 460 470 480 490 500 Here we are accessing the power of R, which is designed to do lots of computations based on a single line of code. "],
["vectors.html", "2 Vectors 2.1 Creating numeric vectors 2.2 Character vectors 2.3 Logical vectors", " 2 Vectors In making the long_x variable, we are making a ‘vector’. In this case, it is a sequence of numbers. A technical definition for a vector is ‘a sequence of values of the same data type.’ To better understand this we need to think about ‘types of data’. The three data types we need to understand for now are: numbers (‘numeric’) words (‘characters’), and TRUE/FALSE (‘logical’) For example, whole numbers can be added, subtracted and so forth. This ‘numeric’ data type is qualitatively different to a word. Words hold meaning, but can’t be sensibly used in a mathematical equation. TRUE and FALSE have specific, logical meaning for computers. Most of what we do in R is turned into TRUE/FALSE problems which are evaluated ‘under the hood.’ 2.1 Creating numeric vectors Above we used a shortcut to create a vector of 50 numbers ( 1:50 ). Ordinarily, we need to enclose values in brackets, separated by commas. The values also need to be ‘concatenated’ using a function called c(). #This new variable will contain a vector of numbers, which in this case is a concatenation of 5, 12 and 22. numeric_vector &lt;- c(5,12,22) 2.2 Character vectors Character values are written in quotation marks, and character vectors are also constructed using c(). char_vector &lt;- c(&#39;dog&#39;,&#39;cat&#39;,&#39;pidgeon&#39;) What happens when you add a character vector to a numeric vector? numeric_vector + char_vector ## Error in numeric_vector + char_vector: non-numeric argument to binary operator Nothing sensible. R will return an error. 2.3 Logical vectors Finally we can create a vector of logical values. Note that for TRUE and FALSE (always in upper case), quotation marks aren’t used. logi_vector &lt;- c(TRUE,TRUE,FALSE) TRUE and FALSE appear in coloured text, indicating that they have a special meaning in the R language. What happens when we add logical data to numeric data? numeric_vector + logi_vector ## [1] 6 13 22 Can you work out how R has calculated this answer? Essentially, the logical data has been automatically converted to numeric data. The TRUE values become 1, and FALSE become 0. Another thing to note is that the values in the vector have been added in their respective orders: position1: 5 + 1 = 6 position2: 12 + 1 = 13 position3: 22 + 0 = 22 This is called ‘type coercion,’ which we’ll return to later. "],
["packages.html", "3 Packages 3.1 Installing packages", " 3 Packages As mentioned above, many developers have built 1000s of functions and shared them with the R user community to help make everyone’s work easier and more efficient. These functions (short programs) are generally packaged up together in (wait for it) ‘Packages’. For example, the ‘tidyverse’ package is a compilation of many different functions, all of which help with data transformation and visualization. Packages also contain data, which is often included to assist new users with learning the available functions. To access this wealth of pre-existing functions, we install packages from the Comprehensive R Archive Network (CRAN) …and if you want the all scripts from The Office (American series) in tabular form, there’s a package for that. 3.1 Installing packages To install a package from CRAN, use the ‘install.packages()’ function: #install packages using the package names in quotes install.packages(&#39;tidyverse&#39;) This will spit out a lot of text into the console as the package is being installed. Once complete you should have a message The downloaded binary packages are in... followed by a long directory name. To access the package functions in our RStudio session, we load the package like so: #load packages using library(package_name), and drop the quotes library(tidyverse) Note that to install a package requires the package name in quotations. Once installed, to load it we drop the quotation marks. "],
["the-pipe.html", "4 The pipe %&gt;%", " 4 The pipe %&gt;% When using functions provided in the tidyverse package, we suggest to write your commands from left to right. This makes reading, and finding bugs in the code, a lot easier. To write code in this way requires a specific symbol, called the pipe which allows the code to be processed in a left-right manner. The pipe symbol looks like this: %&gt;% It is a pain to type manually, so we suggest you use a shortcut: CMD + SHIFT + M (mac) or CTRL + SHIFT + M (pc). It takes a little practice, but quickly enables a great increase in your coding speed. The pipe-based method of coding can help new users to become ‘fluent in R’. Let’s try using the pipe with some data that is packaged up with the tidyverse, called the ‘miles per gallon (mpg)’ data set. This is the data set you saw above, containing information on the mechanical features of different models of car. First we will assign the currently hidden mpg data set to an explicit variable ‘mpg_df’ in our environment. mpg_df &lt;- mpg Now we access the contents of mpg_df, and ‘send it into a function’ called head(). The head() function returns the first six rows of a data set (or first six values in a vector) to the console. #see the first six rows of the mpg data set #call mpg_df first, then &#39;send it into&#39; the head function, using the pipe %&gt;% mpg_df %&gt;% head() ## # A tibble: 6 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compact ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compact ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compact ## 4 audi a4 2 2008 4 auto(av) f 21 30 p compact ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compact ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compact Note that unlike the log() and c() functions we used earlier, here the brackets after head() are empty. This still works because the pipe %&gt;% is sending the mpg_df dataset into the head() function. It has the same outcome as: head(mpg_df) "],
["data-frames.html", "5 Data frames", " 5 Data frames The final concept we need to understand before starting to make plots in R, are ‘data frames’. The vectors we created above are a simple type of ‘data structure’. Whereas vectors can be thought of as a 1-dimensional data structure (a sequence of values), data frames are a 2D data structure. Data frames have both rows and columns. Each column is infact a vector, containing a single type of data. Data frames generally have column names, which we can treat in the same way as a variable. For example, let’s combine our three vectors into a data frame, using the data_frame() function: #combine vectors of the same length into a data frame new_df &lt;- data_frame(numeric_vector, char_vector, logi_vector) new_df ## # A tibble: 3 x 3 ## numeric_vector char_vector logi_vector ## &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 5 dog TRUE ## 2 12 cat TRUE ## 3 22 pidgeon FALSE Importantly, each column in a data frame must have the same number of values (i.e., the same number of rows). This will be a familiar data structure for those who use Microsoft Excel, and is very popular in data science. To make plots in R for this tutorial, we must provide our data in data frame form. "],
["week-1-part-2-making-beautiful-plots.html", "Week 1. Part 2: Making beautiful plots Introductory information", " Week 1. Part 2: Making beautiful plots Introductory information This tutorial leads on from the Week 1 Part 1 tutorial. If you have opened a new R session in RStudio, first load the tidyverse package: library(tidyverse) "],
["ggplot2-a-grammar-of-graphics.html", "6 ggplot2. A grammar of graphics", " 6 ggplot2. A grammar of graphics The ggplot2 package is widely used and valued for its simple, consistent approach to making plots. The ‘grammar’ of graphics relates to different components of a plot that function like different parts of linguistic grammar. For example, all plots require axes, so the x and y axes form one part of the ‘language’ of a plot. Similarly, all plots have data represented between the axes, often as points, lines or bars. The visual way that the data is represented forms another component of the grammar of graphics. Furthermore, the colour, shape or size of points and lines can be used to encode additional information in the plot. This information is usually clarified in a key, or legend, which can also be considered part of this ‘grammar’. The most common components of a ggplot are aesthetics geometric representations facets coordinate space coordinate labels plot theme We will cover each below. The philosophy of ggplot is much better explained by the package author, Hadley Wickham here. For now, we just need to be aware that ggplots are constructed by specifying the different components that we want to display, based on underlying information in a data frame. "],
["building-a-ggplot.html", "7 Building a ggplot 7.1 Plot background 7.2 Aesthetics aes() 7.3 Geometric representations geom() 7.4 Adding colour 7.5 Adding layers 7.6 Facets 7.7 Coordinate space 7.8 Axis labels 7.9 Themes", " 7 Building a ggplot We are going to use the mpg_df data set created previously. If this is not visible in your environement pane, you can recreate it now: mpg_df &lt;- mpg Let’s check the first 6 rows of information contained in the mpg_df data frame, using the head() function: mpg_df %&gt;% head() ## # A tibble: 6 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compact ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compact ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compact ## 4 audi a4 2 2008 4 auto(av) f 21 30 p compact ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compact ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compact Here, we aim to produce a scatter plot of the engine volume (‘displacement’) vs fuel efficiency/mileage in the city (‘cty’), for each class of vehicle. The points on the plot will be coloured based on the vehicle class (right-most column). 7.1 Plot background To start building the plot, we first specify the data frame that contains the relevant data. Here we are ‘sending the mpg_df data set into the ggplot function’: #render plot background mpg_df %&gt;% ggplot() Running this command will produce an empty grey panel. This is because we need to specify how different columns of the data frame should be represented in the plot. 7.2 Aesthetics aes() We can call in different columns of data from mpg_df based on their column names. Column names are given as ‘aesthetic’ elements to the ggplot function, and are wrapped in the aes() function. Because we want a scatter plot, each point will have an x and a y coordinate. We want the x axis to represent engine volume ( x = displ ), and the y axis to represent the city mileage ( y = cty ). We give these specifications separated by a comma. Note that quotes are not required when giving variables within aes(). Those interested in why quotes aren’t required can read here about non-standard evaluation. mpg_df %&gt;% ggplot(aes(x = displ, y = cty)) So far we have the gridlines for our x and y axis. ggplot knows the variables required for the plot, and thus the scale, but has no information about how to display the data points. 7.3 Geometric representations geom() Given we want a scatter plot, we need to specify that the geometric representation of the data will be in point form, using geom_point(). Here we are adding a layer (hence the + sign) of points to the plot. We can think of this as similar to e.g. Adobe Photoshop which uses layers of images that can be reordred and modified individually. For ggplot, each layer will be added over the plot according to its position in the code. mpg_df %&gt;% ggplot(aes(x = displ, y = cty)) + geom_point() Now we have the scatter plot! Each row in the mpg_df data set now has an x coordinate, a y coordinate, and a designated geometric representation (point). From this we can see that vehicles with smaller engines (lower displacement) tend to have higher mileage in the city. 7.3.1 A note about %&gt;% and + ggplot2, an early component of the tidyverse package, was written before the pipe was introduced. The + sign in ggplot2 functions in a similar way to the pipe in other functions in the tidyverse: by allowing code to be written from left to right. 7.4 Adding colour The current plot could be more informative, to include information about the class of each vehicle. In order to achieve this we need to use aes() again, and specify which column in mpg_df we want to be represented as the colour of the points. Here, the aes() function containing the relevant column name, is given within the geom_point() function. mpg_df %&gt;% ggplot(aes(x = displ, y = cty)) + geom_point(aes(colour = class)) So now we can see that the subcompact class (purple points) tends to have small engines and good city mileage, whereas the SUVs (pink points) have very low city mileage and larger engines. As commands get longer, we suggest to add carriage returns (new lines), which are best inserted after the %&gt;% or + symbols. In most cases, R is blind to white space and new lines, so this is simply to make our code more readable. 7.5 Adding layers We can see the relationship between engine size and mileage. But what if we want to model this relationship with a trend line? We can add another ‘layer’ to this plot, using a different geometric representation of the data. In this case a trend line, which is in fact a summary of the data rather than a representation of each point. The geom_smooth() function draws a trend line through the data. The default behaviour is to draw a local regression line (curve) through the points, however these can be hard to interpret. We want to add a straight line based on a linear model (‘lm’) of the relationship between x and y. #add another layer of data representation. mpg_df %&gt;% ggplot(aes(x = displ, y = cty)) + geom_point(aes(colour = class)) + geom_smooth(method=&#39;lm&#39;) Note that the trend line is blocking out cetain points, because it is the ‘top layer’ of the plot. The geom layers that appear early in the command are drawn first, and can be obscured by the geom layers that come after them. What happens if you switch the order of the geom_point() and geom_smooth() functions above? What do you notice about the trend line? 7.6 Facets In some cases we want to break up a single plot into sub-plots, called ‘faceting’. Facets are commonly used when there is too much data to display clearly in a single plot. We will revisit faceting below, however for now, let’s try to facet the mpg_df plot according to vehicle engine size (displ). To do this we use the tilde symbol ‘~’ to indicate the column name that will form each facet. mpg_df %&gt;% ggplot(aes(x = displ, y = cty)) + geom_point(aes(colour = class)) + geom_smooth(method=&#39;lm&#39;) + facet_wrap( ~ class) Note that the aesthetics and geoms including the regression line that were specified for the original plot, are applied to each of the facets. 7.7 Coordinate space ggplot will automatically pick the scale for each axis, and the type of coordinate space. Most plots are in cartesian (linear X vs linear Y) coordinate space. For the mpg_df plot, let’s say we want the x and y origin to be set at 0. To do this we can add in xlim() and ylim() functions, which define the limits of the axes: mpg_df %&gt;% ggplot(aes(x = displ, y = cty)) + geom_point(aes(colour = class)) + geom_smooth(method=&#39;lm&#39;) + xlim(0,7) + ylim(0,40) Further, we can control the coordinate space using coord() functions. Say we want to flip the x and y axes, we add coord_flip(): mpg_df %&gt;% ggplot(aes(x = displ, y = cty)) + geom_point(aes(colour = class)) + geom_smooth(method=&#39;lm&#39;) + xlim(0,7) + ylim(0,40) + coord_flip() 7.8 Axis labels By default, the axis labels will be the column names we gave as aesthetics aes(). We can change the axis labels using the xlab() and ylab() functions. Given that column names are often short and can be cryptic, this functionality is particularly important for effectively communicating results. mpg_df %&gt;% ggplot(aes(x = displ, y = cty)) + geom_point(aes(colour = class)) + geom_smooth(method=&#39;lm&#39;) + xlim(0,7) + ylim(0,40) + xlab(&#39;Engine size (L)&#39;) + ylab(&#39;Miles per gallon in the city&#39;) We can also add a title and subtitle with ggtitle() mpg_df %&gt;% ggplot(aes(x = displ, y = cty)) + geom_point(aes(colour = class)) + geom_smooth(method=&#39;lm&#39;) + xlim(0,7) + ylim(0,40) + xlab(&#39;Engine size (L)&#39;) + ylab(&#39;Miles per gallon in the city&#39;) + ggtitle(label = &#39;Engine size affects mileage&#39;, subtitle = &#39;Some extra info here too&#39;) 7.9 Themes Finally, the overall appearance of the plot can be modified using theme() functions. The default theme has a grey background which maximizes contrast with other contrasts. You may prefer a ‘classic’ theme, a black &amp; white theme or even theme_void(). Try them out. There ggthemes package has plenty of other options. mpg_df %&gt;% ggplot(aes(x = displ, y = cty)) + geom_point(aes(colour = class)) + geom_smooth(method=&#39;lm&#39;) + xlim(0,7) + ylim(0,40) + xlab(&#39;Engine size (L)&#39;) + ylab(&#39;Miles per gallon in the city&#39;) + ggtitle(label = &#39;Engine size affects mileage&#39;, subtitle = &#39;Some extra info here too&#39;) + theme_bw() "],
["week-1-part-3-making-more-beautiful-plots.html", "Week 1. Part 3: Making more beautiful plots Introductory information", " Week 1. Part 3: Making more beautiful plots Introductory information This tutorial leads on from the Week 1 Part 2 tutorial. We now explore approaches for plotting large datasets. If you have opened a new R session in RStudio, first load the tidyverse package: library(tidyverse) We now create a larger data set in the global environment, called ‘diamond_df’. This is based on the diamonds data set that is provided as part of the tidyverse diamond_df &lt;- diamonds N.B. If your computer is taking a long time to plot this data set in the steps below, then take a smaller sample of 2500 rows. I don’t recommend overwriting objects in general, but doing this will make the following section more accessible. Also note that your plots will look slightly different to those below. set.seed(1234) ; diamond_df &lt;- diamond_df %&gt;% sample_n(2500) "],
["bigger-data-54000-diamonds.html", "8 Big(ger) Data: 54,000 diamonds 8.1 Summary plots 8.2 Histograms 8.3 Density plots 8.4 Box plots", " 8 Big(ger) Data: 54,000 diamonds When ploting a small dataset such as mpg_df, its possible to visualize every individual data point. This is impractical for large datasets, where we run into the problem of ‘overplotting’. We therefore need approaches for managing over-plotting. These include but aren’t limited to: reducing density summing, and summarizing the data. To explore these options we will now move on to a much larger data set containing multiple measurements for 54,000 diamonds. The measurements appear in separate columns, and each diamond appears in a different row. As for mpg, this data is available through the tidyverse package. https://www.diamonds.pro/wp-content/uploads/2019/02/diamond-depth-and-table.png First let’s view the first 6 rows of the diamond_df dataset img from: https://www.diamond.pro/education/diamond-depth-and-table/ diamond_df %&gt;% head() ## # A tibble: 6 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 0.290 Premium I VS2 62.4 58 334 4.2 4.23 2.63 ## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 You can read the definitions of each measurement (column name) in the help manual for the original (‘hidden’) dataset by typing ?diamonds We can get the number of rows and columns (the ‘dimensions’) of this dataset using the dim() function: diamond_df %&gt;% dim() ## [1] 53940 10 First let’s make a scatter plot comparing the price of diamonds (y) by cut (x): diamond_df %&gt;% ggplot(aes(x=cut, y=price)) + geom_point() Because there are 54K points here the plot is essentially useless. What can we do to get more information about the relationship? ## geom_jitter() This adds some random scatter to the points which can reduce over-plotting. Note that to avoid mis-representing the price, we should set the jitter height to 0. diamond_df %&gt;% ggplot(aes(x=cut, y=price)) + geom_jitter(height=0) This is somewhat improved but far from good. Next we will make the points more transparent using the ‘alpha’ setting within geom_jitter. diamond_df %&gt;% ggplot(aes(x=cut, y=price)) + geom_jitter(height=0, alpha=0.25) The density below $5000 can be further reduced by limiting the size of the points, again within the geom_jitter() command. diamond_df %&gt;% ggplot(aes(x=cut, y=price)) + geom_jitter(height=0, alpha=0.25, size=0.5) Now we can see much more detail in the data, including an interesting lack of data around the $3000 mark in the Very Good and Premium cut data. This could be due to other features such as size, carat or clarity. We will return to these possibilities later. 8.1 Summary plots Its clear that the cut group sizes are uneven. To get a quick summary of the numbers of diamonds per group, we can make a bar plot. Here we specify only the group we wish to count (i.e. the number of diamonds of each cut) as the x aesthetic. Importantly, the group size is summed and displayed automatically when we specify geom_bar(). diamond_df %&gt;% ggplot(aes(x=cut)) + geom_bar() Alternatively, if we want to find the total value of the diamonds in each group, we use a related geom that sums the values in a column (rather than the number of rows), called geom_col. Here we give price, that is, the column whose values we want to sum, as the y axis aesthetic. diamond_df %&gt;% ggplot(aes(x=cut, y=price)) + geom_col() From this we can see the total value of the Ideal cut diamonds alone is &gt; $70 million! 8.1.1 Free examples! If you are unsure how to use a function in R, the help page will usually have Example code at the bottom. ?geom_bar() You can copy and paste these examples and they should work first time. The code below is taken directly from the first example for geom_bar(): # geom_bar is designed to make it easy to create bar charts that show # counts (or sums of weights) g &lt;- ggplot(mpg, aes(class)) # Number of cars in each class: g + geom_bar() To add more information, we could count the clarity groups per cut group. Adding clarity into the aesthetic as the bar fill color will automatically calculate and display these sub-groups. diamond_df %&gt;% ggplot(aes(x = cut, fill=clarity)) + geom_bar() We can rearrange the clarity groups into adjascent (dodged) bars by specifying a different position within geom_bar(): diamond_df %&gt;% ggplot(aes(x = cut, fill=clarity)) + geom_bar(position=&#39;dodge&#39;) 8.2 Histograms When dealing with large datasets especially for statistical testing, histograms are essential for understanding the distribution of values. Like geom_bar() above, geom_histogram() requires only a single x aesthetic, specifying the values to be displayed. Further, the values will be automatically sorted into 30 bins and the number of rows of data per bin summed up. Here we plot the distribution of prices across the entire dataset. diamond_df %&gt;% ggplot(aes(x = price)) + geom_histogram() To increase the resolution of the histogram, lets specify 200 bins: diamond_df %&gt;% ggplot(aes(x=price)) + geom_histogram(bins=200) Here we can see an interesting lack of data around $1000. Let’s zoom in using xlim, and add some fill color. diamond_df %&gt;% ggplot(aes(x = price)) + geom_histogram(bins=200, fill = &#39;dodgerblue&#39;) + xlim(0,2500) ## Warning: Removed 26398 rows containing non-finite values (stat_bin). ## Warning: Removed 2 rows containing missing values (geom_bar). There are virtually no diamonds around the $1500 mark. What could be the reason for this? R will give a warning that some data is not represented in the plot. This is part of the ggplot philosophy that ‘data should not go missing silently.’ 8.3 Density plots Whereas it can be difficult to represent multiple sub-groups in a histogram, density plots are another essential tool for exploring your data. These are essentially smoothed histograms, where the area under the curve for each sub-group will sum to 1. This allows us to compare sub-groups of different size. diamond_df %&gt;% ggplot(aes(x = price)) + geom_density(aes(colour =cut)) 8.4 Box plots img from: https://miro.medium.com/max/18000/1*2c21SkzJMf3frPXPAR_gZA.png Box plots, or ‘box &amp; wisker plots’ are another essential tool for data analysis, which are related to histograms and density plots. Box plots summarize the distribution of a set of values by displaying the minimum and maximum values, the median (i.e. middle-ranked value), and the range of the middle 50% of values (interquartile range). The wisker line extending above and below the IQR box define Q3 + (1.5 x IQR), and Q1 - (1.5 x IQR) respectively. You can read more about box plots here. To create box plot from our data we use (no prizes here) geom_boxplot()! diamond_df %&gt;% ggplot(aes(x=cut, y=price)) + geom_boxplot() The points indicate outlier values [i.e., those greater than Q3 + (1.5xIQR) ]. We can overlay a boxplot on the scatterplot for the entire dataset, to fully communicate both the raw and summary data. Here we reduce the width of the jitter points slightly, and set the IQR box to be fully transparent using alpha. Note that this setting also hides the outlier points in geom_boxplot. diamond_df %&gt;% ggplot(aes(x=cut, y=price)) + geom_jitter(height=0, alpha=0.25, size=0.5, width=0.3) + geom_boxplot(alpha=0) Because its now difficult to see the box plots, we can colour only the geom_boxplot by setting the colour aesthetic within that geom: diamond_df %&gt;% ggplot(aes(x=cut, y=price)) + geom_jitter(height=0, alpha=0.25, size=0.5, width=0.3) + geom_boxplot(alpha=0, aes(colour =cut)) The legend contains the same information as the x axis, and is therefore redundant. We can drop the legend by giving an additional command to geom_boxplot: diamond_df %&gt;% ggplot(aes(x=cut, y=price)) + geom_jitter(height=0, alpha=0.25, size=0.5, width=0.3) + geom_boxplot(alpha=0, aes(colour =cut), show.legend = FALSE) In fact, a box plot displays very similar information to a density plot, rotated 90°. Violin plots, which reflect the sample density, can be used together with a box plot to convey even more detail about the distribution of a set of values. Here we limit the width of geom_boxplot to sit within geom_violin. Because both geoms will be coloured in the same way, we can give the color aesthetic directly to ggplot(). Similarly, because we dont want the legend, we will remove it using the theme() function. diamond_df %&gt;% ggplot(aes(x=cut, y=price, colour =cut)) + geom_boxplot(alpha=0, width=0.15) + geom_violin(alpha=0) + theme(legend.position = &#39;none&#39;) "],
["saving-plots.html", "9 Saving plots", " 9 Saving plots ggplot includes a neat function ggsave() which allows us to save plots in many formats By default ggsave() will save the most recent plot. It writes a file depending on the extension you provide. To save the plot that is currently in your Plots window: ggsave(&#39;~/Desktop/my_ggplot.pdf&#39;, width=5,height=4) To save a specific plot, its possible to store the plot as a variable, which is given to ggsave(): myplot &lt;- mpg %&gt;% ggplot(aes(x=displ, y=cty)) + geom_point(aes(colour =class)) ggsave(plot = myplot, &#39;~/Desktop/my_ggplot.pdf&#39;, width = 5, height = 4) In general, if you want to increase the size of points and text, then reduce the dimensions of the plot; and vice versa. "],
["challenge.html", "10 Challenge 10.1 Solution", " 10 Challenge Based on what you’ve learnt, can you make a scatter plot that shows the relationship between diamond carat and price, with points coloured by clarity (reduced in size to 0.2), and faceted by cut? What do you notice about the distribution of carat? More generally, what has this exploratory data analysis taught us about human psychology when it comes to diamonds? 10.1 Solution diamond_df %&gt;% ggplot(aes(x=carat, y=price, colour =clarity)) + geom_point(size=0.2) + facet_wrap(~cut) "],
["week-2-part-1-subsetting-vectors.html", "Week 2. Part 1: Subsetting vectors 10.2 Subset by position 10.3 Adding names 10.4 Subset by condition 10.5 Challenge 10.6 Possible solutions", " Week 2. Part 1: Subsetting vectors A very common task in data wrangling is filtering or ‘subsetting’ down to a smaller set of potentially interesting values. This short chapter is intended to give you a basic understanding of the operations that R is performing when filtering and evaluating data using the functions introduced in Chapter 5. Note that it is not necessary to have the tidyverse package loaded to complete this chapter - we are using ‘base R’ functions. First we will create a vector named ‘beatles’ containing the years of birth of The Beatles: John Lennon: 1940, Ringo Starr: 1940, Paul McCartney: 1942 and George Harrison: 1943. beatles &lt;- c(1940,1940,1942,1943) 10.2 Subset by position To hone in on different values in this vector we can request them based on their position in order 1 through 4. The position is given in square brackets beatles[1] ## [1] 1940 Returns just the value at the first position in the vector. Importantly, we can subset for values at position 2 and 3 by including a vector of numbers defining those positions. beatles[c(2,3)] ## [1] 1940 1942 We can also request everything but the value at a certain position, using the minus sign beatles[-3] ## [1] 1940 1940 1943 10.3 Adding names To add additional information to the values we can give each a name, supplied as a vector of words: names(beatles) &lt;- c(&#39;John&#39;,&#39;Ringo&#39;,&#39;Paul&#39;,&#39;George&#39;) Notice how the beatles variable has now changed slightly in the Environment panel. From now on every time a value is returned from the beatles vector, the Beatle member associated with that value is also returned. beatles[-3] ## John Ringo George ## 1940 1940 1943 10.4 Subset by condition In addition to subsetting a vector by the position of values, we can ‘pose questions’ about the set of values to R, which will be returned with TRUE or FALSE answers. ‘Which Beatles date of birth is 1940’? To code this we ask for values ‘exactly equal to’ 1940, using the == sign. beatles == 1940 ## John Ringo Paul George ## TRUE TRUE FALSE FALSE R returns ‘TRUE’ for values that satisfy our ‘condition’, and FALSE for those that don’t. ‘Which member(s) date of birth is before 1943?.’ To code this we use the less-than &lt; sign. beatles &lt; 1943 ## John Ringo Paul George ## TRUE TRUE TRUE FALSE R is assessing the value at each position, and returning an answer to our conditional question. A way to directly subset this vector is to directly provide a vector of TRUE and FALSE values within square brackets, in a similar manner to specifying the positions, above. beatles[c(TRUE,FALSE,FALSE,TRUE)] ## John George ## 1940 1943 Note that the only values returned are in the ‘TRUE’ positions, in this case the values at position 1 and 4. We can see that subsetting a vector is based on the presence of a ‘TRUE’ or ‘FALSE’ statement at each position along the vector. In most cases when subsetting data, we want the values themselves, rather than the TRUE/FALSE evaluations. Now that we know that i) conditional requests return TRUE/FALSE values, and ii) TRUE/FALSE values are the basis of sub-setting vectors, we can substitute the TRUE/FALSE vector in the brackets above for a conditional statement: beatles[beatles &gt; 1940] ## Paul George ## 1942 1943 To check this, try running just the code within the square brackets. It is timely to mention that in R, code is processed from the inside- to outside of brackets. Here, the conditional statement is evaluated and produces a vector of four TRUE / FALSE values. This logical vector is then used to sub-set the original vector, returning a subset of named numeric values. ‘Which Beatles were not born in 1942?.’ To answer this we need to use a ! symbol that ‘negates’, or inverts the condition: beatles[ beatles!=1942 ] ## John Ringo George ## 1940 1940 1943 To get an even more succinct answer, we could request only the names associated with the numeric values: names( beatles[ beatles != 1942] ) ## [1] &quot;John&quot; &quot;Ringo&quot; &quot;George&quot; You will use these types of conditional statments regularly in the next chapter. 10.5 Challenge Create three different commands to return information about the Beatles born before 1943. You can use positional information, and/or conditional requests. 10.6 Possible solutions beatles[beatles &lt; 1943] ## John Ringo Paul ## 1940 1940 1942 beatles[beatles != 1943] ## John Ringo Paul ## 1940 1940 1942 beatles[-4] ## John Ringo Paul ## 1940 1940 1942 beatles[c(1,2,3)] ## John Ringo Paul ## 1940 1940 1942 beatles[names(beatles) != &#39;George&#39;] ## John Ringo Paul ## 1940 1940 1942 "],
["week-2-part-2-dplyr.html", "Week 2. Part 2: dplyr 10.7 filter() 10.8 select() 10.9 arrange() 10.10 Chaining dplyr functions 10.11 Writing data to a file 10.12 Chaining dplyr and ggplot 10.13 mutate() 10.14 summarize() 10.15 group_by() helper 10.16 Challenges 10.17 Solutions 10.18 Summary 10.19 Extra resources", " Week 2. Part 2: dplyr The dplyr package, part of the tidyverse, is designed to make manipulating and transforming data as simple and intuitive as possible. A guiding principle for tidyverse packages (and RStudio), is to minimize the number of keystrokes and characters required to get the results you want. To this end, as for ggplot, in dplyr, quotation marks for the column names of data frames are often not required. Another key feature of the tidyverse data wrangling packages such as dplyr, is that the input to and output from all functions, are data frames. dplyr features a handful of key functions, also termed ‘verbs’, which can be combined to achieve very specific results. You will notice similarities to the functions available in Microsoft Excel. We will explore the first of these verbs using the mpg_df dataset created earlier. If starting from a new Rstudio session you should run the following code: 10.7 filter() The filter() function subsets the rows in a data frame by testing against a conditional statement. The output from a successful filter() will be a data frame with fewer rows than the input data frame. Let’s filter the mpg_df data for cars manufacturered in the year 1999: mpg_df %&gt;% filter(year == 1999) ## # A tibble: 117 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compact ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compact ## 3 audi a4 2.8 1999 6 auto(l5) f 16 26 p compact ## 4 audi a4 2.8 1999 6 manual(m5) f 18 26 p compact ## 5 audi a4 quattro 1.8 1999 4 manual(m5) 4 18 26 p compact ## 6 audi a4 quattro 1.8 1999 4 auto(l5) 4 16 25 p compact ## 7 audi a4 quattro 2.8 1999 6 auto(l5) 4 15 25 p compact ## 8 audi a4 quattro 2.8 1999 6 manual(m5) 4 17 25 p compact ## 9 audi a6 quattro 2.8 1999 6 auto(l5) 4 15 24 p midsize ## 10 chevrolet c1500 suburban 2wd 5.7 1999 8 auto(l4) r 13 17 r suv ## # … with 107 more rows Here we are ‘sending’ the mpg_df data frame into the function filter(), which tests each value in the year column for the number 1999, and returns those rows where the filter() condition is TRUE. If you are working in an R text document (.R format) or directly in the console, after running this command you will see the dimensions of the output data frame printed in grey text above the column names. Alternatively you can ‘send’ the output of filter (a data frame) into the dim() function. mpg_df %&gt;% filter(year==1999) %&gt;% dim() ## [1] 117 11 We can also filter on character data. For example, let’s take all vehicles in the ‘midsize’ class: mpg_df %&gt;% filter(class==&#39;midsize&#39;) ## # A tibble: 41 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a6 quattro 2.8 1999 6 auto(l5) 4 15 24 p midsize ## 2 audi a6 quattro 3.1 2008 6 auto(s6) 4 17 25 p midsize ## 3 audi a6 quattro 4.2 2008 8 auto(s6) 4 16 23 p midsize ## 4 chevrolet malibu 2.4 1999 4 auto(l4) f 19 27 r midsize ## 5 chevrolet malibu 2.4 2008 4 auto(l4) f 22 30 r midsize ## 6 chevrolet malibu 3.1 1999 6 auto(l4) f 18 26 r midsize ## 7 chevrolet malibu 3.5 2008 6 auto(l4) f 18 29 r midsize ## 8 chevrolet malibu 3.6 2008 6 auto(s6) f 17 26 r midsize ## 9 hyundai sonata 2.4 1999 4 auto(l4) f 18 26 r midsize ## 10 hyundai sonata 2.4 1999 4 manual(m5) f 18 27 r midsize ## # … with 31 more rows Can you filter mpg_df for all vehicles except the hyundais? 10.7.1 Logical operations 10.7.1.1 &amp; and We can achieve more specific filters by combining conditions across columns. For example, we use the “&amp;” sign to filter for vehicles built in 1999 and with mileage in the city (cty) greater than 18. mpg_df %&gt;% filter(year == 1999 &amp; cty &gt; 18) ## # A tibble: 33 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 manual(m5) f 21 29 p compact ## 2 chevrolet malibu 2.4 1999 4 auto(l4) f 19 27 r midsize ## 3 honda civic 1.6 1999 4 manual(m5) f 28 33 r subcompact ## 4 honda civic 1.6 1999 4 auto(l4) f 24 32 r subcompact ## 5 honda civic 1.6 1999 4 manual(m5) f 25 32 r subcompact ## 6 honda civic 1.6 1999 4 manual(m5) f 23 29 p subcompact ## 7 honda civic 1.6 1999 4 auto(l4) f 24 32 r subcompact ## 8 hyundai tiburon 2 1999 4 auto(l4) f 19 26 r subcompact ## 9 hyundai tiburon 2 1999 4 manual(m5) f 19 29 r subcompact ## 10 nissan altima 2.4 1999 4 manual(m5) f 21 29 r compact ## # … with 23 more rows To see the entire output you can pipe the output from filter into a View() commmand mpg_df %&gt;% filter(year==1999 &amp; cty &gt; 18) %&gt;% View() 10.7.1.2 | or Alternatively we might want to filter for vehicles (i.e., rows) where the manufacturer is chevrolet or the class is ‘suv’. This requires the “|” symbol (shift + \\) mpg_df %&gt;% filter(manufacturer==&#39;chevrolet&#39; | class==&#39;suv&#39;) ## # A tibble: 72 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 chevrolet c1500 suburban 2wd 5.3 2008 8 auto(l4) r 14 20 r suv ## 2 chevrolet c1500 suburban 2wd 5.3 2008 8 auto(l4) r 11 15 e suv ## 3 chevrolet c1500 suburban 2wd 5.3 2008 8 auto(l4) r 14 20 r suv ## 4 chevrolet c1500 suburban 2wd 5.7 1999 8 auto(l4) r 13 17 r suv ## 5 chevrolet c1500 suburban 2wd 6 2008 8 auto(l4) r 12 17 r suv ## 6 chevrolet corvette 5.7 1999 8 manual(m6) r 16 26 p 2seater ## 7 chevrolet corvette 5.7 1999 8 auto(l4) r 15 23 p 2seater ## 8 chevrolet corvette 6.2 2008 8 manual(m6) r 16 26 p 2seater ## 9 chevrolet corvette 6.2 2008 8 auto(s6) r 15 25 p 2seater ## 10 chevrolet corvette 7 2008 8 manual(m6) r 15 24 p 2seater ## # … with 62 more rows 10.7.1.3 and/or To take it a step further we can combine &amp; and | in the same filter command. Adding curved brackets will help to clarify the order of operations. Let’s filter for the vehicles where the manufacturer is chevrolet or the class is ‘suv’, and all vehicles with highway mileage less than 20. mpg_df %&gt;% filter( (manufacturer==&#39;chevrolet&#39; | class==&#39;suv&#39;) &amp; hwy &lt; 20) ## # A tibble: 48 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 chevrolet c1500 suburban 2wd 5.3 2008 8 auto(l4) r 11 15 e suv ## 2 chevrolet c1500 suburban 2wd 5.7 1999 8 auto(l4) r 13 17 r suv ## 3 chevrolet c1500 suburban 2wd 6 2008 8 auto(l4) r 12 17 r suv ## 4 chevrolet k1500 tahoe 4wd 5.3 2008 8 auto(l4) 4 14 19 r suv ## 5 chevrolet k1500 tahoe 4wd 5.3 2008 8 auto(l4) 4 11 14 e suv ## 6 chevrolet k1500 tahoe 4wd 5.7 1999 8 auto(l4) 4 11 15 r suv ## 7 chevrolet k1500 tahoe 4wd 6.5 1999 8 auto(l4) 4 14 17 d suv ## 8 dodge durango 4wd 3.9 1999 6 auto(l4) 4 13 17 r suv ## 9 dodge durango 4wd 4.7 2008 8 auto(l5) 4 13 17 r suv ## 10 dodge durango 4wd 4.7 2008 8 auto(l5) 4 9 12 e suv ## # … with 38 more rows 10.7.2 str_detect() helper function Often we want to capture rows containing a particular sequence of letters. For example, there are 10 different vehicle models containing the letters ‘4wd’. We don’t want to have to write an ‘or’ command with 10 alternatives. A much better way is to ‘detect’ the letters ‘4wd’ in the model column, and return all rows where they are present, using str_detect(). str_detect() is a command within filter() which requires the column name, followed by the letters (in quotes) to search for mpg_df %&gt;% filter(str_detect(model,&#39;4wd&#39;)) ## # A tibble: 74 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 chevrolet k1500 tahoe 4wd 5.3 2008 8 auto(l4) 4 14 19 r suv ## 2 chevrolet k1500 tahoe 4wd 5.3 2008 8 auto(l4) 4 11 14 e suv ## 3 chevrolet k1500 tahoe 4wd 5.7 1999 8 auto(l4) 4 11 15 r suv ## 4 chevrolet k1500 tahoe 4wd 6.5 1999 8 auto(l4) 4 14 17 d suv ## 5 dodge dakota pickup 4wd 3.7 2008 6 manual(m6) 4 15 19 r pickup ## 6 dodge dakota pickup 4wd 3.7 2008 6 auto(l4) 4 14 18 r pickup ## 7 dodge dakota pickup 4wd 3.9 1999 6 auto(l4) 4 13 17 r pickup ## 8 dodge dakota pickup 4wd 3.9 1999 6 manual(m5) 4 14 17 r pickup ## 9 dodge dakota pickup 4wd 4.7 2008 8 auto(l5) 4 14 19 r pickup ## 10 dodge dakota pickup 4wd 4.7 2008 8 auto(l5) 4 14 19 r pickup ## # … with 64 more rows Note that the letter order and case have to be matched exactly. How would you filter for all vehicles with automatic transmission? 10.8 select() Whereas filter() subsets a dataframe by row, select() returns a subset of the columns. This function can take column names (even without quotes), or the column position number beginning at left. Further, unlike in base R, commands within the brackets in select() do not need to be concatenated using c(). Let’s extract the car model, engine volume (displ) and highway mileage (hwy) from mpg_df: mpg_df %&gt;% select(model, displ, hwy) ## # A tibble: 234 x 3 ## model displ hwy ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 a4 1.8 29 ## 2 a4 1.8 29 ## 3 a4 2 31 ## 4 a4 2 30 ## 5 a4 2.8 26 ## 6 a4 2.8 26 ## 7 a4 3.1 27 ## 8 a4 quattro 1.8 26 ## 9 a4 quattro 1.8 25 ## 10 a4 quattro 2 28 ## # … with 224 more rows We can use ‘-’ to extract all except particular column(s). For example, to drop the model and year columns: mpg_df %&gt;% select(-model, -year) ## # A tibble: 234 x 9 ## manufacturer displ cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi 1.8 4 auto(l5) f 18 29 p compact ## 2 audi 1.8 4 manual(m5) f 21 29 p compact ## 3 audi 2 4 manual(m6) f 20 31 p compact ## 4 audi 2 4 auto(av) f 21 30 p compact ## 5 audi 2.8 6 auto(l5) f 16 26 p compact ## 6 audi 2.8 6 manual(m5) f 18 26 p compact ## 7 audi 3.1 6 auto(av) f 18 27 p compact ## 8 audi 1.8 4 manual(m5) 4 18 26 p compact ## 9 audi 1.8 4 auto(l5) 4 16 25 p compact ## 10 audi 2 4 manual(m6) 4 20 28 p compact ## # … with 224 more rows We can also specify column positions. Take the data in columns number 1,5 and 11 mpg_df %&gt;% select(1,5,11) ## # A tibble: 234 x 3 ## manufacturer cyl class ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 audi 4 compact ## 2 audi 4 compact ## 3 audi 4 compact ## 4 audi 4 compact ## 5 audi 6 compact ## 6 audi 6 compact ## 7 audi 6 compact ## 8 audi 4 compact ## 9 audi 4 compact ## 10 audi 4 compact ## # … with 224 more rows Or combine column positions and names: mpg_df %&gt;% select(1,3, cty, hwy) ## # A tibble: 234 x 4 ## manufacturer displ cty hwy ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 audi 1.8 18 29 ## 2 audi 1.8 21 29 ## 3 audi 2 20 31 ## 4 audi 2 21 30 ## 5 audi 2.8 16 26 ## 6 audi 2.8 18 26 ## 7 audi 3.1 18 27 ## 8 audi 1.8 18 26 ## 9 audi 1.8 16 25 ## 10 audi 2 20 28 ## # … with 224 more rows 10.8.1 contains() helper function contains() is a helper function used with select(), which is analagous to the str_detect() helper used with filter(). To select only columns with names containing the letter ‘y’: mpg_df %&gt;% select(contains(&#39;y&#39;)) ## # A tibble: 234 x 4 ## year cyl cty hwy ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1999 4 18 29 ## 2 1999 4 21 29 ## 3 2008 4 20 31 ## 4 2008 4 21 30 ## 5 1999 6 16 26 ## 6 1999 6 18 26 ## 7 2008 6 18 27 ## 8 1999 4 18 26 ## 9 1999 4 16 25 ## 10 2008 4 20 28 ## # … with 224 more rows contains() is also useful for selecting all column names featuring a certain character, e.g. contains(’_’) 10.8.2 starts_with() helper function start_with() and ends_with() offer more specificity for select(). If we want all columns begining with the letter ‘c’: mpg_df %&gt;% select(starts_with(&#39;c&#39;)) ## # A tibble: 234 x 3 ## cyl cty class ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 4 18 compact ## 2 4 21 compact ## 3 4 20 compact ## 4 4 21 compact ## 5 6 16 compact ## 6 6 18 compact ## 7 6 18 compact ## 8 4 18 compact ## 9 4 16 compact ## 10 4 20 compact ## # … with 224 more rows Happily we can even mix these helper functions with the standard select commands: mpg_df %&gt;% select( 2, 1, class, contains(&#39;y&#39;)) ## # A tibble: 234 x 7 ## model manufacturer class year cyl cty hwy ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 a4 audi compact 1999 4 18 29 ## 2 a4 audi compact 1999 4 21 29 ## 3 a4 audi compact 2008 4 20 31 ## 4 a4 audi compact 2008 4 21 30 ## 5 a4 audi compact 1999 6 16 26 ## 6 a4 audi compact 1999 6 18 26 ## 7 a4 audi compact 2008 6 18 27 ## 8 a4 quattro audi compact 1999 4 18 26 ## 9 a4 quattro audi compact 1999 4 16 25 ## 10 a4 quattro audi compact 2008 4 20 28 ## # … with 224 more rows 10.8.3 everything() helper function Lastly for select(), a very useful helper is the everything() function, which returns all column names that have not been specified. It is often used when reordering all columns in a dataframe: mpg_df %&gt;% select(class,displ,year,everything()) ## # A tibble: 234 x 11 ## class displ year manufacturer model cyl trans drv cty hwy fl ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 compact 1.8 1999 audi a4 4 auto(l5) f 18 29 p ## 2 compact 1.8 1999 audi a4 4 manual(m5) f 21 29 p ## 3 compact 2 2008 audi a4 4 manual(m6) f 20 31 p ## 4 compact 2 2008 audi a4 4 auto(av) f 21 30 p ## 5 compact 2.8 1999 audi a4 6 auto(l5) f 16 26 p ## 6 compact 2.8 1999 audi a4 6 manual(m5) f 18 26 p ## 7 compact 3.1 2008 audi a4 6 auto(av) f 18 27 p ## 8 compact 1.8 1999 audi a4 quattro 4 manual(m5) 4 18 26 p ## 9 compact 1.8 1999 audi a4 quattro 4 auto(l5) 4 16 25 p ## 10 compact 2 2008 audi a4 quattro 4 manual(m6) 4 20 28 p ## # … with 224 more rows Note that the dimensions of the dataframe have not changed, merely the column order. 10.9 arrange() arrange() is the simplest of the dplyr functions, which orders rows according to values in a given column. The default is to order numbers from lowest -&gt; highest. Let’s try ordering the vehicles by engine size (displ) mpg_df %&gt;% arrange(displ) ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 honda civic 1.6 1999 4 manual(m5) f 28 33 r subcompact ## 2 honda civic 1.6 1999 4 auto(l4) f 24 32 r subcompact ## 3 honda civic 1.6 1999 4 manual(m5) f 25 32 r subcompact ## 4 honda civic 1.6 1999 4 manual(m5) f 23 29 p subcompact ## 5 honda civic 1.6 1999 4 auto(l4) f 24 32 r subcompact ## 6 audi a4 1.8 1999 4 auto(l5) f 18 29 p compact ## 7 audi a4 1.8 1999 4 manual(m5) f 21 29 p compact ## 8 audi a4 quattro 1.8 1999 4 manual(m5) 4 18 26 p compact ## 9 audi a4 quattro 1.8 1999 4 auto(l5) 4 16 25 p compact ## 10 honda civic 1.8 2008 4 manual(m5) f 26 34 r subcompact ## # … with 224 more rows We can refine the order by giving additional columns of data. To order rows by manufacturer name (alphabetical), then by engine size then by city mileage: mpg_df %&gt;% arrange(manufacturer, displ, cty ) ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 quattro 1.8 1999 4 auto(l5) 4 16 25 p compact ## 2 audi a4 1.8 1999 4 auto(l5) f 18 29 p compact ## 3 audi a4 quattro 1.8 1999 4 manual(m5) 4 18 26 p compact ## 4 audi a4 1.8 1999 4 manual(m5) f 21 29 p compact ## 5 audi a4 quattro 2 2008 4 auto(s6) 4 19 27 p compact ## 6 audi a4 2 2008 4 manual(m6) f 20 31 p compact ## 7 audi a4 quattro 2 2008 4 manual(m6) 4 20 28 p compact ## 8 audi a4 2 2008 4 auto(av) f 21 30 p compact ## 9 audi a4 quattro 2.8 1999 6 auto(l5) 4 15 25 p compact ## 10 audi a6 quattro 2.8 1999 6 auto(l5) 4 15 24 p midsize ## # … with 224 more rows 10.9.1 desc() helper function To invert the standard order, we can use the ‘descending’ desc() helper function. To find the most fuel-efficient vehicles when on the highway, we could use: mpg_df %&gt;% arrange(desc(hwy)) ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 volkswagen jetta 1.9 1999 4 manual(m5) f 33 44 d compact ## 2 volkswagen new beetle 1.9 1999 4 manual(m5) f 35 44 d subcompact ## 3 volkswagen new beetle 1.9 1999 4 auto(l4) f 29 41 d subcompact ## 4 toyota corolla 1.8 2008 4 manual(m5) f 28 37 r compact ## 5 honda civic 1.8 2008 4 auto(l5) f 25 36 r subcompact ## 6 honda civic 1.8 2008 4 auto(l5) f 24 36 c subcompact ## 7 toyota corolla 1.8 1999 4 manual(m5) f 26 35 r compact ## 8 toyota corolla 1.8 2008 4 auto(l4) f 26 35 r compact ## 9 honda civic 1.8 2008 4 manual(m5) f 26 34 r subcompact ## 10 honda civic 1.6 1999 4 manual(m5) f 28 33 r subcompact ## # … with 224 more rows 10.10 Chaining dplyr functions Coding from left-to-right using the pipe %&gt;% allows us to make ‘chains’ of commands to achieve very specific results. Let’s filter for the midsize vehicles, then select the columns class, manufacturer, displ and year, and arrange on engine size (displ): mpg_df %&gt;% filter(class==&#39;midsize&#39;) %&gt;% select(class,manufacturer,displ,year) %&gt;% arrange(displ) ## # A tibble: 41 x 4 ## class manufacturer displ year ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 midsize volkswagen 1.8 1999 ## 2 midsize volkswagen 1.8 1999 ## 3 midsize volkswagen 2 2008 ## 4 midsize volkswagen 2 2008 ## 5 midsize toyota 2.2 1999 ## 6 midsize toyota 2.2 1999 ## 7 midsize chevrolet 2.4 1999 ## 8 midsize chevrolet 2.4 2008 ## 9 midsize hyundai 2.4 1999 ## 10 midsize hyundai 2.4 1999 ## # … with 31 more rows Using line-breaks makes the order of operations very easy to read (and fix if necessary). Once we’re happy with the output of this chain of functions, we can assign it to a new object (aka variable) in the environment: mpg_slim &lt;- mpg_df %&gt;% filter(class==&#39;midsize&#39;) %&gt;% select(class,manufacturer,displ,year) %&gt;% arrange(displ) Note that all of the functions will be performed before the output is assigned into mpg_slim. Therefore even though mpg_slim is at the top of the code, it will contain the final output dataframe. 10.11 Writing data to a file The new mpg_slim data frame could be saved to a file outside of the R session using write_tsv() write_tsv() creates a tab-separated file that can be read by applications like Excel. We first give the variable name, then the file name (ideally with a full directory location): On Mac: write_tsv(mpg_slim, &#39;~/Desktop/mpg_slim_dataframe.tsv&#39;) On PC: write_tsv(mpg_slim, &#39;C:/Users/ansell.b/Desktop/mpg_slim_dataframe.tsv&#39;) We will learn how to read data in to R in the next chapter. 10.12 Chaining dplyr and ggplot We can also send the dplyr output directly into ggplot! mpg_df %&gt;% filter(class==&#39;midsize&#39;) %&gt;% select(class,manufacturer,displ,year) %&gt;% arrange(displ) %&gt;% ggplot(aes(x=class,y=displ)) + geom_boxplot() Whereas this is very useful for quickly manipulating and plotting data, for readability you might prefer to separate the dplyr commands from the ggplot commands like so: #first create smaller dataset mpg_slim &lt;- mpg_df %&gt;% filter(class==&#39;midsize&#39;) %&gt;% select(class,manufacturer,displ,year) %&gt;% arrange(displ) #then plot the distribution of engine volumes of &#39;midsize&#39; cars mpg_slim %&gt;% ggplot(aes(x=class,y=displ)) + geom_boxplot() 10.13 mutate() Whereas the the verbs we’ve covered so far modify the dimensions and order of the existing data frame, mutate() adds new columns of data, thus ‘mutating’ the contents and dimensions of the input data frame. To explore mutate we will use the diamond_df data frame from earlier. You can recreate if necessary: diamond_df &lt;- ggplot2::diamonds The price column for these diamonds is in US dollars. If we want to convert the price to Australian dollars we can (optimistically) multiply USD by 1.25. Here we create a new column called AUD, which will contain a new column where each row = price * 1.25. Because the number of columns is expanding, to easily see the results we can first drop the x/y/z dimension columns using select() diamond_df %&gt;% select(-x, -y, -z) %&gt;% mutate(AUD = price * 1.25) ## # A tibble: 53,940 x 8 ## carat cut color clarity depth table price AUD ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 408. ## 2 0.21 Premium E SI1 59.8 61 326 408. ## 3 0.23 Good E VS1 56.9 65 327 409. ## 4 0.290 Premium I VS2 62.4 58 334 418. ## 5 0.31 Good J SI2 63.3 58 335 419. ## 6 0.24 Very Good J VVS2 62.8 57 336 420 ## 7 0.24 Very Good I VVS1 62.3 57 336 420 ## 8 0.26 Very Good H SI1 61.9 55 337 421. ## 9 0.22 Fair E VS2 65.1 61 337 421. ## 10 0.23 Very Good H VS1 59.4 61 338 422. ## # … with 53,930 more rows We can also perform operations using only the data in existing columns. Here as above, the newly created column will contain the results of a mathematical operation, performed row by row. Let’s calculate the US dollars per carat (‘ppc’) by dividing the price column by the carat column diamond_df %&gt;% select(-x,-y,-z) %&gt;% mutate(ppc = price/carat) ## # A tibble: 53,940 x 8 ## carat cut color clarity depth table price ppc ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 1417. ## 2 0.21 Premium E SI1 59.8 61 326 1552. ## 3 0.23 Good E VS1 56.9 65 327 1422. ## 4 0.290 Premium I VS2 62.4 58 334 1152. ## 5 0.31 Good J SI2 63.3 58 335 1081. ## 6 0.24 Very Good J VVS2 62.8 57 336 1400 ## 7 0.24 Very Good I VVS1 62.3 57 336 1400 ## 8 0.26 Very Good H SI1 61.9 55 337 1296. ## 9 0.22 Fair E VS2 65.1 61 337 1532. ## 10 0.23 Very Good H VS1 59.4 61 338 1470. ## # … with 53,930 more rows 10.13.1 Challenge One carat weighs 0.2 grams. Can you chain multiple mutate() functions together to calculate for each diamond, the Australian Dollars per gram? ### Solution diamond_df %&gt;% select(-x,-y,-z) %&gt;% mutate(grams = 0.2 * carat) %&gt;% mutate(AUD = price * 1.25) %&gt;% mutate(aud_per_gram = AUD/grams) ## # A tibble: 53,940 x 10 ## carat cut color clarity depth table price grams AUD aud_per_gram ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 0.046 408. 8859. ## 2 0.21 Premium E SI1 59.8 61 326 0.042 408. 9702. ## 3 0.23 Good E VS1 56.9 65 327 0.046 409. 8886. ## 4 0.290 Premium I VS2 62.4 58 334 0.0580 418. 7198. ## 5 0.31 Good J SI2 63.3 58 335 0.062 419. 6754. ## 6 0.24 Very Good J VVS2 62.8 57 336 0.048 420 8750 ## 7 0.24 Very Good I VVS1 62.3 57 336 0.048 420 8750 ## 8 0.26 Very Good H SI1 61.9 55 337 0.052 421. 8101. ## 9 0.22 Fair E VS2 65.1 61 337 0.044 421. 9574. ## 10 0.23 Very Good H VS1 59.4 61 338 0.046 422. 9185. ## # … with 53,930 more rows 10.13.2 ifelse() helper The mutate() function is very useful for making a new column of labels for the existing data. For example, to label outliers, or a sub-set of genes with particular characteristics. This is where ifelse() comes in. ifelse() is a function that tests each value in a column of data for a particular condition (a logical test), and returns one answer when the condition==TRUE, and another when the condition==FALSE. Specifically, ifelse() takes three commands: the condition to test, the output when TRUE, and the output when FALSE. To see how this works let’s create a label for each diamond depending on whether we consider it ‘expensive’ (&gt; $5000) or ‘cheap’ (&lt; $5000). diamond_df %&gt;% select(-x,-y,-z) %&gt;% mutate(price_label = ifelse(price &gt; 5000, &#39;expensive&#39;, &#39;cheap&#39;)) ## # A tibble: 53,940 x 8 ## carat cut color clarity depth table price price_label ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 cheap ## 2 0.21 Premium E SI1 59.8 61 326 cheap ## 3 0.23 Good E VS1 56.9 65 327 cheap ## 4 0.290 Premium I VS2 62.4 58 334 cheap ## 5 0.31 Good J SI2 63.3 58 335 cheap ## 6 0.24 Very Good J VVS2 62.8 57 336 cheap ## 7 0.24 Very Good I VVS1 62.3 57 336 cheap ## 8 0.26 Very Good H SI1 61.9 55 337 cheap ## 9 0.22 Fair E VS2 65.1 61 337 cheap ## 10 0.23 Very Good H VS1 59.4 61 338 cheap ## # … with 53,930 more rows Remember that we need two closing brackets, one for the mutate() function, and one for the ifelse() inside it. It seems that the ifelse() function has worked. All the rows we can see are price &lt; 5000 and labeled ‘cheap’. But how can we be sure? One option to check the new labels is to plot the price column as a histogram, and fill the bars according to price_label: diamond_df %&gt;% select(-x,-y,-z) %&gt;% mutate(price_label = ifelse(price &gt; 5000,&#39;expensive&#39;,&#39;cheap&#39;)) %&gt;% ggplot(aes(x=price, fill = price_label)) + geom_histogram() Now we can be confident that ifelse() command has worked as intended. Another option for checking output is to use count(), which will be introduced below. 10.13.3 case_when() helper This function is useful but quite involved. I’m including it here for completeness, however beginners can feel free to skip down to the summarize() section and return to case_when() later. At times we want to create a label column that tests multiple conditions. We can either put multiple ifelse() commands inside each other (and go mad), or use case_when()! This command takes multiple conditions and tests them in order. This is important to remember as all rows that satisfy the first condition will be tagged as such. There may be rows that satisfy more than one condition, so you should order the tests from specific to general, and keep track of how those ambiguous rows are being treated. case_when() takes a conditional command in the same format as the first command in ifelse(), however only the action for the TRUE condition is given, separated with a tilde ~. The catch-all command for rows that do not satisfy any other conditions, is given at the end. Let’s use case_when() to make a label for diamonds based on their clarity super-groups. For simplicy, we select only the clarity column as input. The current clarity categories are: IF: internally flawless VVS1 and 2: very very slight impurity 1 and 2 VS1 and 2: very slight impurity 1 and 2 SI1 and 2: slight impurity 1 and 2 I1: impurity Note that we are searching for similar conditions (‘VVS’ contains ‘VS’) and will have to be careful with the order of conditions. To create the super-groupings we will use a combination of str_detect() and equality == conditions. diamond_df %&gt;% select(clarity) %&gt;% mutate(clarity_group = case_when(clarity == &#39;IF&#39; ~ &#39;flawless&#39;, str_detect(clarity, &#39;VVS&#39;) ~ &#39;VV_slight&#39;, str_detect(clarity, &#39;VS&#39;) ~ &#39;V_slight&#39;, str_detect(clarity, &#39;SI&#39;) ~ &#39;slight&#39;, clarity == &#39;I1&#39; ~ &#39;impurity&#39;, TRUE ~ &#39;other&#39;)) ## # A tibble: 53,940 x 2 ## clarity clarity_group ## &lt;ord&gt; &lt;chr&gt; ## 1 SI2 slight ## 2 SI1 slight ## 3 VS1 V_slight ## 4 VS2 V_slight ## 5 SI2 slight ## 6 VVS2 VV_slight ## 7 VVS1 VV_slight ## 8 SI1 slight ## 9 VS2 V_slight ## 10 VS1 V_slight ## # … with 53,930 more rows Note that both VS1 and VS2 diamonds are now taged as ‘V_slight’, and similarliy VVS1 and VVS2 are taged as ‘VV_slight’. Because we have captured all clarity categories within the list of conditions, we dont expect the catch-all output, “other”, to be present in the clarity_group column. We could use %&gt;% count(clarity_group), introduced below, to check for the presence of unintended values such as ‘other’ or NA. These super-groups could now be used for coloring or faceting data in a plot, or creating summary statistics (see below). 10.14 summarize() The last of the dplyr verbs is summarize(), which as the name suggests, creates individual summary statistics from larger data sets. As for mutate(), the output of summarize() is qualitatively different from the input: it is generally a smaller dataframe with a reduced representation of the input data. Importantly, even though the output of summarize() can be very small, it is still a dataframe. Although not essential, it is also a good idea to specify new column names for the summary statistics that this function creates. First we will calculate the mean price for the diamond_df dataframe by specifying a name for the new data, and then the function we want to apply to the price column: diamond_df %&gt;% summarize(mean_price = mean(price)) ## # A tibble: 1 x 1 ## mean_price ## &lt;dbl&gt; ## 1 3933. The output is the smallest possible dataframe: 1 row X 1 column. We can create additional summary statistics by adding them in a comma-separated sequence. For example, to calculate the standard deviation, mininum and maximum values, we create three additional columns: “sd_price”, “min_price”, and “max_price” diamond_df %&gt;% summarize(mean_price = mean(price), sd_price = sd(price), min_price = min(price), max_price = max(price)) ## # A tibble: 1 x 4 ## mean_price sd_price min_price max_price ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 3933. 3989. 326 18823 10.14.1 n() helper When using summarize(), we can also count the number of rows being summarized, which can be important for interpreting the associated statistics. The simple function n() never takes any additional code, but simply counts rows: diamond_df %&gt;% summarize(mean_price = mean(price), sd_price = sd(price), min_price = min(price), max_price = max(price), n_rows = n()) ## # A tibble: 1 x 5 ## mean_price sd_price min_price max_price n_rows ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 3933. 3989. 326 18823 53940 So far so good, however this seems like quite a lot of code to get the simple summary statistics. The power of this function is really amplified in conjuction with the group_by() helper. 10.15 group_by() helper Although I’ve called group_by() a helper function, it is key to unleashing the power of nearly all dplyr functions. group_by() allows us to create sub-groups based on labels in a particular column, and to run subsequent functions on all sub-groups. It is conceptually similar to facet_wrap() in ggplot, which applies the same plotting command to multiple subsets of the input dataframe. For example the figure below is using group_by() as the first arrow, and summarize() as the second arrow. Three sub-groups, corresponding to e.g. three categories in column 1, are represented in the light grey, blue and green rows. A summarize() command is then run on each sub-group, producing a results dataframe with only three rows, and new (dark blue) column names indicating the summary statistic. For those interested in more details, group_by() is essentially creating a separate dataframe for each category in a specified column. To see this at work, look the structure str() of the diamonds data before and after grouping: diamond_df %&gt;% str() ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 53940 obs. of 10 variables: ## $ carat : num 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ... ## $ cut : Ord.factor w/ 5 levels &quot;Fair&quot;&lt;&quot;Good&quot;&lt;..: 5 4 2 4 2 3 3 3 1 3 ... ## $ color : Ord.factor w/ 7 levels &quot;D&quot;&lt;&quot;E&quot;&lt;&quot;F&quot;&lt;&quot;G&quot;&lt;..: 2 2 2 6 7 7 6 5 2 5 ... ## $ clarity: Ord.factor w/ 8 levels &quot;I1&quot;&lt;&quot;SI2&quot;&lt;&quot;SI1&quot;&lt;..: 2 3 5 4 2 6 7 3 4 5 ... ## $ depth : num 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ... ## $ table : num 55 61 65 58 58 57 57 55 61 61 ... ## $ price : int 326 326 327 334 335 336 336 337 337 338 ... ## $ x : num 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ... ## $ y : num 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ... ## $ z : num 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ... We have a single dataframe with 54K rows. Now we group by cut: diamond_df %&gt;% group_by(cut) %&gt;% str() ## Classes &#39;grouped_df&#39;, &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 53940 obs. of 10 variables: ## $ carat : num 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ... ## $ cut : Ord.factor w/ 5 levels &quot;Fair&quot;&lt;&quot;Good&quot;&lt;..: 5 4 2 4 2 3 3 3 1 3 ... ## $ color : Ord.factor w/ 7 levels &quot;D&quot;&lt;&quot;E&quot;&lt;&quot;F&quot;&lt;&quot;G&quot;&lt;..: 2 2 2 6 7 7 6 5 2 5 ... ## $ clarity: Ord.factor w/ 8 levels &quot;I1&quot;&lt;&quot;SI2&quot;&lt;&quot;SI1&quot;&lt;..: 2 3 5 4 2 6 7 3 4 5 ... ## $ depth : num 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ... ## $ table : num 55 61 65 58 58 57 57 55 61 61 ... ## $ price : int 326 326 327 334 335 336 336 337 337 338 ... ## $ x : num 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ... ## $ y : num 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ... ## $ z : num 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ... ## - attr(*, &quot;groups&quot;)=Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 5 obs. of 2 variables: ## ..$ cut : Ord.factor w/ 5 levels &quot;Fair&quot;&lt;&quot;Good&quot;&lt;..: 1 2 3 4 5 ## ..$ .rows:List of 5 ## .. ..$ : int 9 92 98 124 125 129 130 205 228 242 ... ## .. ..$ : int 3 5 11 18 19 21 36 37 38 43 ... ## .. ..$ : int 6 7 8 10 20 22 23 24 25 26 ... ## .. ..$ : int 2 4 13 15 16 27 46 54 55 57 ... ## .. ..$ : int 1 12 14 17 40 41 42 52 53 56 ... ## ..- attr(*, &quot;.drop&quot;)= logi TRUE The output of group_by() is a ‘grouped_df’ and all functions following will be applied separately to each sub-dataframe. 10.15.1 group_by() %&gt;% summarize() Returning to the above summarize() function, we can now quickly generate summary statistics for the diamonds in each clarity category by first grouping on this column name. diamond_df %&gt;% group_by(clarity) %&gt;% summarize(mean_price = mean(price), sd_price = sd(price), min_price = min(price), max_price = max(price), n_rows = n()) ## # A tibble: 8 x 6 ## clarity mean_price sd_price min_price max_price n_rows ## &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 I1 3924. 2807. 345 18531 741 ## 2 SI2 5063. 4260. 326 18804 9194 ## 3 SI1 3996. 3799. 326 18818 13065 ## 4 VS2 3925. 4042. 334 18823 12258 ## 5 VS1 3839. 4012. 327 18795 8171 ## 6 VVS2 3284. 3822. 336 18768 5066 ## 7 VVS1 2523. 3335. 336 18777 3655 ## 8 IF 2865. 3920. 369 18806 1790 Huzzah! By adding this simple command before summarize() we’ve created detailed statistics on each clarity category. We could split the input data further by grouping on more than one column. For example, what are the summary statistics for each clarity category within each cut? diamond_df %&gt;% group_by(clarity, cut) %&gt;% summarize(mean_price = mean(price), sd_price = sd(price), min_price = min(price), max_price = max(price), n_rows = n()) ## # A tibble: 40 x 7 ## # Groups: clarity [8] ## clarity cut mean_price sd_price min_price max_price n_rows ## &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 I1 Fair 3704. 3099. 584 18531 210 ## 2 I1 Good 3597. 2285. 361 11548 96 ## 3 I1 Very Good 4078. 2720. 511 15984 84 ## 4 I1 Premium 3947. 2827. 345 16193 205 ## 5 I1 Ideal 4336. 2671. 413 16538 146 ## 6 SI2 Fair 5174. 3928. 536 18308 466 ## 7 SI2 Good 4580. 3901. 335 18788 1081 ## 8 SI2 Very Good 4989. 4126. 383 18692 2100 ## 9 SI2 Premium 5546. 4488. 345 18784 2949 ## 10 SI2 Ideal 4756. 4252. 326 18804 2598 ## # … with 30 more rows We now have 40 rows of summary statistics which gives a higher-resolution representation of the input data. 10.15.2 group_by() %&gt;% mutate() As mentioned, group_by() is compatible with all other dplyr functions. Sometimes we want both the original data and the summary statistics in the output data frame. To do this, group_by() can be combined with mutate(), to make a new column of summary statistics (repeated many times) corresponding to the sub-grouping of interest. The new column of summary statistics is represented in darker colours in the right panel below. To create a column containing the mean price for diamonds in each cut category in addition to the input data, we can use group_by() before mutate(): diamond_df %&gt;% select(-x,-y,-z) %&gt;% group_by(cut) %&gt;% mutate(cut_meanprice = mean(price)) ## # A tibble: 53,940 x 8 ## # Groups: cut [5] ## carat cut color clarity depth table price cut_meanprice ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3458. ## 2 0.21 Premium E SI1 59.8 61 326 4584. ## 3 0.23 Good E VS1 56.9 65 327 3929. ## 4 0.290 Premium I VS2 62.4 58 334 4584. ## 5 0.31 Good J SI2 63.3 58 335 3929. ## 6 0.24 Very Good J VVS2 62.8 57 336 3982. ## 7 0.24 Very Good I VVS1 62.3 57 336 3982. ## 8 0.26 Very Good H SI1 61.9 55 337 3982. ## 9 0.22 Fair E VS2 65.1 61 337 4359. ## 10 0.23 Very Good H VS1 59.4 61 338 3982. ## # … with 53,930 more rows The new column now contains one of five possible values depending on the cut column. From this we could then use a second mutate() to calculate the difference between each diamond price and the mean price for its cut category: diamond_df %&gt;% select(-x,-y,-z) %&gt;% group_by(cut) %&gt;% mutate(cut_meanprice = mean(price)) %&gt;% mutate(price_diff = price - cut_meanprice) ## # A tibble: 53,940 x 9 ## # Groups: cut [5] ## carat cut color clarity depth table price cut_meanprice price_diff ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3458. -3132. ## 2 0.21 Premium E SI1 59.8 61 326 4584. -4258. ## 3 0.23 Good E VS1 56.9 65 327 3929. -3602. ## 4 0.290 Premium I VS2 62.4 58 334 4584. -4250. ## 5 0.31 Good J SI2 63.3 58 335 3929. -3594. ## 6 0.24 Very Good J VVS2 62.8 57 336 3982. -3646. ## 7 0.24 Very Good I VVS1 62.3 57 336 3982. -3646. ## 8 0.26 Very Good H SI1 61.9 55 337 3982. -3645. ## 9 0.22 Fair E VS2 65.1 61 337 4359. -4022. ## 10 0.23 Very Good H VS1 59.4 61 338 3982. -3644. ## # … with 53,930 more rows 10.15.3 ungroup() helper When running longer dplyr chains it is good practice to ungroup the data after the group_by() operations are run. To do this simply add %&gt;% ungroup() at the end of the code block. Inappropriate preservation of groupings can sometimes cause your code to run very slowly and give unexpected results. 10.15.4 count() helper count() is a shortcut function that combines group_by() and summarize(), which is useful for counting ‘character data’, e.g. labels. To quickly count the number of diamonds in each cut category: diamond_df %&gt;% count(cut) ## # A tibble: 5 x 2 ## cut n ## &lt;ord&gt; &lt;int&gt; ## 1 Fair 1610 ## 2 Good 4906 ## 3 Very Good 12082 ## 4 Premium 13791 ## 5 Ideal 21551 And to count the number of diamonds in each cut and clarity category: diamond_df %&gt;% count(cut,clarity) ## # A tibble: 40 x 3 ## cut clarity n ## &lt;ord&gt; &lt;ord&gt; &lt;int&gt; ## 1 Fair I1 210 ## 2 Fair SI2 466 ## 3 Fair SI1 408 ## 4 Fair VS2 261 ## 5 Fair VS1 170 ## 6 Fair VVS2 69 ## 7 Fair VVS1 17 ## 8 Fair IF 9 ## 9 Good I1 96 ## 10 Good SI2 1081 ## # … with 30 more rows Note that the count summary output column name is ‘n’. This reflects that count() is using a summarize(n = n()) function in the background. 10.15.5 sample_n() helper The final helper for this session is sample_n() which takes a random sample of rows according to the number specified. To sample 10 rows from the entire diamond_df dataset: diamond_df %&gt;% sample_n(10) ## # A tibble: 10 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.71 Premium H VS1 62.8 58 2398 5.7 5.67 3.57 ## 2 1.01 Premium G SI2 63 59 3923 6.38 6.32 4 ## 3 1.54 Very Good G VS1 63.4 57 14433 7.28 7.36 4.64 ## 4 1.09 Premium G SI2 61.3 60 3601 6.66 6.59 4.06 ## 5 1.24 Very Good G VS1 60.2 58 9738 6.96 7 4.2 ## 6 0.71 Premium F SI1 62.7 57 2633 5.68 5.65 3.55 ## 7 1.52 Fair D SI2 56.3 61 7702 7.7 7.62 4.31 ## 8 1.5 Premium H SI2 62.3 60 8490 7.22 7.3 4.52 ## 9 0.42 Premium E VS2 60.9 59 958 4.81 4.85 2.94 ## 10 0.26 Very Good F SI1 59.6 55 590 4.18 4.24 2.51 It can be more useful to sample rows from within sub-groups, by combining group_by() and sample_n(). Let’s take 2 rows at random from each cut category: diamond_df %&gt;% group_by(cut) %&gt;% sample_n(2) ## # A tibble: 10 x 10 ## # Groups: cut [5] ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1.9 Fair H SI2 67.1 64 8576 7.57 7.52 5.06 ## 2 1 Fair H SI1 67.6 59 4665 6.03 5.95 4.05 ## 3 1.5 Good I VS2 61.3 61 8920 7.31 7.38 4.5 ## 4 0.39 Good F SI1 63.6 58 921 4.65 4.6 2.94 ## 5 0.26 Very Good E VVS2 62.6 58 597 4.07 4.11 2.56 ## 6 0.41 Very Good E SI2 63.5 55 818 4.73 4.69 2.99 ## 7 1.14 Premium G SI2 60.4 59 4884 6.8 6.78 4.1 ## 8 1.28 Premium G VS1 60.9 58 9335 7.01 7.09 4.29 ## 9 2.59 Ideal J VS1 61.7 56 16465 8.83 8.77 5.43 ## 10 1 Ideal J SI1 59.2 62 3929 6.47 6.5 3.84 10.16 Challenges What is the weight of the most expensive diamond in each clarity category? Summarize the standard deviation of diamond weight in each cut category. A z score is the (sample value - mean)/sd. Can you create a z score for the weight of each diamond relative to others of that cut? What does the density distribution of z scores look like for each cut? 10.17 Solutions diamond_df %&gt;% group_by(clarity) %&gt;% summarize(maxPrice = max(price)) ## # A tibble: 8 x 2 ## clarity maxPrice ## &lt;ord&gt; &lt;int&gt; ## 1 I1 18531 ## 2 SI2 18804 ## 3 SI1 18818 ## 4 VS2 18823 ## 5 VS1 18795 ## 6 VVS2 18768 ## 7 VVS1 18777 ## 8 IF 18806 diamond_df %&gt;% group_by(cut) %&gt;% summarize(sdWt = sd(carat)) ## # A tibble: 5 x 2 ## cut sdWt ## &lt;ord&gt; &lt;dbl&gt; ## 1 Fair 0.516 ## 2 Good 0.454 ## 3 Very Good 0.459 ## 4 Premium 0.515 ## 5 Ideal 0.433 weight_z &lt;- diamond_df %&gt;% group_by(cut) %&gt;% mutate(meanWt=mean(carat), sdWt = sd(carat), z = (carat - meanWt)/sdWt) weight_z %&gt;% ggplot(aes(x=z)) + geom_density(aes(col=cut)) 10.18 Summary Now you have worked through the key verbs of dplyr, and the associated helper functions which, together, allow you to efficiently subset, transform and summarize your data. Whereas the diamond_df and mpg_df dataframes we have worked with so far are self-contained, readily available within R and clean, in the next chapter we will learn to read in external datasets, join different datasets and clean data. 10.19 Extra resources There are several great resources for consolidating and building on the material above. R for Data Science Ch. 5 ‘Data transformation’ Tidyverse resources Introduction to open data science (Ocean Health Index) Jenny Bryan’s STAT545 course notes "]
]
